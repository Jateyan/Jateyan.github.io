---
title: 响应式系统
createTime: 2025/03/06 20:19:15
permalink: /article/lzdpv3wz/
---
# 响应式系统

## 1. Proxy 替代 Object.defineProperty

### 为什么替换
Vue 3 中使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，主要原因是：

- **完整拦截**：Proxy 可以监听对象的所有属性操作，包括属性添加、删除等
- **数组监听**：可以原生监听数组变化，无需特殊处理
- **性能提升**：懒监听，仅当属性被访问时才进行代理
- **更少的限制**：无需预先递归遍历对象，减少初始化开销

### 代码对比

**Vue 2 方式 (Object.defineProperty)**:
```javascript
let data = { count: 0 }
let vm = {}

Object.keys(data).forEach(key => {
  Object.defineProperty(vm, key, {
    get() {
      console.log(`获取 ${key}: ${data[key]}`)
      return data[key]
    },
    set(newValue) {
      console.log(`设置 ${key}: ${newValue}`)
      data[key] = newValue
    }
  })
})

// 使用
vm.count = 1 // 设置 count: 1
console.log(vm.count) // 获取 count: 1

// 局限性
vm.newProp = 'new' // 新增属性，不会被拦截
delete vm.count // 删除属性，不会被拦截
```

**Vue 3 方式 (Proxy)**:
```javascript
let data = { count: 0 }
let vm = new Proxy(data, {
  get(target, key) {
    console.log(`获取 ${key}: ${target[key]}`)
    return target[key]
  },
  set(target, key, value) {
    console.log(`设置 ${key}: ${value}`)
    target[key] = value
    return true // 必须返回true表示设置成功
  },
  deleteProperty(target, key) {
    console.log(`删除属性: ${key}`)
    delete target[key]
    return true
  }
})

// 使用
vm.count = 1 // 设置 count: 1
console.log(vm.count) // 获取 count: 1

// Proxy优势
vm.newProp = 'new' // 能够拦截新增属性
delete vm.count // 能够拦截删除操作
```

## 2. reactive 和 ref 的区别与使用

### reactive
- 用于将对象转换为响应式对象
- 深度递归代理对象的所有嵌套属性
- 不能用于基本类型(如数字、字符串)

```javascript
import { reactive, watchEffect } from 'vue'

const state = reactive({
  count: 0,
  user: {
    name: '张三',
    age: 25
  }
})

watchEffect(() => {
  console.log(`计数: ${state.count}`)
  console.log(`用户名: ${state.user.name}`)
})

// 更新将触发watchEffect重新运行
state.count++
state.user.name = '李四'

// 注意：解构会失去响应性
const { count } = state
count++ // 不会触发更新
```

### ref
- 可用于基本类型和对象
- 基本类型包装在一个带有 `.value` 属性的对象中
- 对象类型内部会调用 `reactive()` 实现响应式

```javascript
import { ref, watchEffect } from 'vue'

const count = ref(0)
const user = ref({
  name: '张三',
  age: 25
})

watchEffect(() => {
  console.log(`计数: ${count.value}`)
  console.log(`用户名: ${user.value.name}`)
})

// 更新值 - 需要使用.value
count.value++
user.value.name = '李四'

// 在模板中使用时不需要.value
// <template>
//   <div>{{ count }}</div>
//   <div>{{ user.name }}</div>
// </template>
```

### 选择指南
- 使用 **ref** 适合：
  - 处理基本类型数据
  - 需要将响应式对象传递给函数时
  - 在setup返回时保持响应性

- 使用 **reactive** 适合：
  - 处理复杂对象或嵌套数据
  - 避免频繁使用.value
  - 组件内部状态管理

## 3. computed 和 watch 的实现原理

### computed 实现原理
computed 是基于响应式依赖进行缓存的计算属性

```javascript
import { ref, computed, watchEffect } from 'vue'

const count = ref(0)
const doubleCount = computed(() => {
  console.log('计算doubleCount') // 只在依赖变化时执行
  return count.value * 2
})

watchEffect(() => {
  console.log('Count:', count.value)
  console.log('Double count:', doubleCount.value)
})

// 多次访问doubleCount不会重复计算
console.log(doubleCount.value) // 0
console.log(doubleCount.value) // 仍然是0，但不会再次执行计算函数

// 修改依赖会触发重新计算
count.value++
```

**简化实现原理**:
```javascript
function createComputed(getter) {
  let value
  let dirty = true
  
  const effect = createEffect(() => {
    if (dirty) {
      value = getter()
      dirty = false
    }
    return value
  })
  
  return {
    get value() {
      return effect.run()
    },
    // 当依赖变化，将dirty设为true
    _reset() { dirty = true }
  }
}
```

### watch 实现原理
watch 用于监听响应式数据变化并执行回调函数

```javascript
import { ref, watch } from 'vue'

const count = ref(0)
const name = ref('张三')

// 基础用法
watch(count, (newValue, oldValue) => {
  console.log(`count从${oldValue}变成了${newValue}`)
})

// 监听多个来源
watch([count, name], ([newCount, newName], [oldCount, oldName]) => {
  console.log(`count: ${oldCount} -> ${newCount}, name: ${oldName} -> ${newName}`)
})

// 深度监听
const user = ref({ name: '张三', address: { city: '北京' } })
watch(user, (newVal, oldVal) => {
  console.log('用户信息变化:', newVal)
}, { deep: true })

// 触发更新
count.value++
name.value = '李四'
user.value.address.city = '上海'
```

**简化实现原理**:
```javascript
function createWatch(source, callback, options = {}) {
  // 将数据源转换为getter
  const getter = typeof source === 'function' 
    ? source 
    : () => traverse(source)
  
  let oldValue
  
  // 创建effect副作用函数
  const job = () => {
    const newValue = effectFn()
    if (options.deep || newValue !== oldValue) {
      callback(newValue, oldValue)
      oldValue = newValue
    }
  }
  
  const effectFn = createEffect(() => getter())
  
  // 初始化
  if (options.immediate) {
    job()
  } else {
    oldValue = effectFn()
  }
  
  // 返回清除函数
  return () => {
    effectFn.stop()
  }
}

// 用于深度遍历对象以收集依赖
function traverse(value, seen = new Set()) {
  if (typeof value !== 'object' || value === null || seen.has(value)) {
    return value
  }
  seen.add(value)
  
  if (Array.isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen)
    }
  } else {
    for (const key in value) {
      traverse(value[key], seen)
    }
  }
  
  return value
}
```

## 4. 响应式原理深度解析

Vue 3的响应式系统基于三个核心概念：
- **Proxy**: 用于拦截数据操作
- **依赖追踪**: 收集数据的依赖关系
- **响应派发**: 在数据变化时通知相关依赖更新

### 响应式系统工作流程

1. **依赖收集过程**:
```javascript
// 简化的响应式系统实现
let activeEffect // 当前正在执行的副作用函数
const targetMap = new WeakMap() // 存储依赖关系的Map

// 创建响应式对象
function reactive(target) {
  return new Proxy(target, {
    get(target, key) {
      // 1. 依赖收集
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      // 2. 触发更新
      trigger(target, key)
      return true
    }
  })
}

// 依赖收集
function track(target, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target)
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()))
    }
    
    let dep = depsMap.get(key)
    if (!dep) {
      depsMap.set(key, (dep = new Set()))
    }
    
    dep.add(activeEffect)
  }
}

// 触发更新
function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  
  const dep = depsMap.get(key)
  if (dep) {
    dep.forEach(effect => {
      effect()
    })
  }
}

// 创建副作用函数
function effect(fn) {
  const run = () => {
    activeEffect = run
    return fn()
  }
  run()
  return run
}

// 使用示例
const state = reactive({ count: 0 })

effect(() => {
  console.log('Count is:', state.count)
}) 

// 更新数据，将触发effect重新执行
state.count++
```

### 完整的响应式系统工作流程
1. 通过 `reactive()` 或 `ref()` 创建响应式对象
2. 当组件渲染或`effect`/`computed`/`watch`函数执行时，会访问响应式数据
3. 访问数据属性时触发 `get` 拦截器，执行 `track()` 收集当前活跃的副作用函数
4. 当数据变化时，触发 `set` 拦截器，执行 `trigger()` 通知所有相关的副作用函数重新执行
5. 视图更新或相关计算属性重新计算

## 5. toRefs, toRef, unref 等工具函数使用

### toRefs
将响应式对象转换为普通对象，其属性都是对应的 ref

```javascript
import { reactive, toRefs, watchEffect } from 'vue'

const state = reactive({
  name: '张三',
  age: 25
})

// 使用toRefs可以解构保持响应性
const { name, age } = toRefs(state)

watchEffect(() => {
  console.log(`姓名: ${name.value}, 年龄: ${age.value}`)
})

// 通过解构出的ref修改原始数据
name.value = '李四' // state.name也会变成'李四'
state.age = 26      // age.value也会变成26
```

### toRef
为响应式对象的单个属性创建ref

```javascript
import { reactive, toRef, watchEffect } from 'vue'

const state = reactive({
  user: {
    name: '张三',
    age: 25
  }
})

// 为嵌套属性创建ref
const name = toRef(state.user, 'name')

watchEffect(() => {
  console.log(`姓名: ${name.value}`)
})

// 通过ref修改
name.value = '李四' // state.user.name也会变成'李四'
```

### unref
如果参数是ref则返回内部值，否则返回参数本身

```javascript
import { ref, unref } from 'vue'

const count = ref(0)
const name = '张三'

console.log(unref(count)) // 0
console.log(unref(name))  // '张三'

// 常用于工具函数，处理可能是ref或普通值的参数
function printValue(val) {
  const value = unref(val) // 统一处理ref和非ref
  console.log(value)
}

printValue(count) // 0
printValue(name)  // '张三'
```

### isRef
检查值是否为ref对象

```javascript
import { ref, reactive, isRef } from 'vue'

const count = ref(0)
const state = reactive({ name: '张三' })
const plain = { age: 25 }

console.log(isRef(count)) // true
console.log(isRef(state)) // false
console.log(isRef(plain)) // false
```

### shallowRef
创建一个跟踪自身 `.value` 变化但不会使其值也变成响应式的ref

```javascript
import { shallowRef, watchEffect } from 'vue'

const state = shallowRef({ count: 0 })

watchEffect(() => {
  console.log(state.value.count)
})

// 这不会触发更新
state.value.count++ 

// 这会触发更新
state.value = { count: 1 }
```

### 实用技巧
```javascript
import { ref, reactive, toRefs, computed } from 'vue'

// 组合多个响应式数据源
function useUser() {
  const userInfo = reactive({
    name: '张三',
    age: 25
  })
  
  const isAdmin = ref(false)
  
  const displayName = computed(() => {
    return isAdmin.value ? `管理员: ${userInfo.name}` : userInfo.name
  })
  
  // 使用toRefs确保返回的对象属性保持响应性
  return {
    ...toRefs(userInfo),
    isAdmin,
    displayName
  }
}

// 使用
const { name, age, isAdmin, displayName } = useUser()
```
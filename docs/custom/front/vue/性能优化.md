---
title: 性能优化
createTime: 2025/03/06 20:47:42
permalink: /article/6vohzks1/
---
# 性能优化

## 1. 静态树提升 (Static Tree Hoisting)

静态树提升是Vue 3编译器的一项重要优化，它可以识别模板中不会改变的静态内容，并将其提升到渲染函数之外。这意味着这些内容只会被创建一次，后续的渲染过程中不需要重新创建这些节点。

### 工作原理

```javascript
// Vue 2 中的渲染方式 - 每次重新渲染都会创建静态节点
render() {
  return _c('div', [
    _c('h1', { attrs: { id: 'title' }}, [_v('静态标题')]),
    _c('p', [_v('当前计数: ' + _s(this.count))])
  ])
}

// Vue 3 中的渲染方式 - 静态节点被提升
const hoisted = /*#__PURE__*/ _createElementVNode('h1', { id: 'title' }, '静态标题', -1 /* HOISTED */)

function render() {
  return _createElementVNode('div', null, [
    hoisted,
    _createElementVNode('p', null, '当前计数: ' + _toDisplayString(_ctx.count), 1 /* TEXT */)
  ])
}
```

### 优化效果

在一个有大量静态内容的应用中，静态树提升可以显著提高渲染性能：

- 减少每次渲染时的内存分配
- 减少垃圾回收压力
- 加快渲染速度

### 自动应用

静态树提升由Vue编译器自动进行，不需要手动干预。你只需要使用最新版本的Vue 3和相应的构建工具。

## 2. 基于 Proxy 的响应式系统性能优势

Vue 3使用ES6的Proxy替代了Vue 2中的Object.defineProperty，这带来了显著的性能提升。

### 性能优势

#### 1. 懒追踪

```javascript
// Vue 2 - 初始化时递归遍历所有属性
function observe(obj) {
  if (!isObject(obj)) return
  
  // 遍历每个属性
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
    
    // 递归处理嵌套对象
    observe(obj[key])
  })
}

// Vue 3 - 仅在访问时才代理
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver)
      track(target, key) // 追踪依赖
      
      // 仅在访问嵌套对象时才进行代理
      return isObject(res) ? reactive(res) : res
    },
    // 其他处理器...
  })
}
```

#### 2. 更精确的变更检测

```javascript
// Vue 2 的局限性
const data = { items: ['a', 'b'] }
const vm = new Vue({ data })

// 这些操作在Vue 2中不会触发响应
vm.items[0] = 'x'      // 通过索引修改数组
vm.items.length = 1    // 修改数组长度
vm.$set(vm.items, 0, 'x') // 需要使用特殊API

// Vue 3 中可以直接操作
const state = reactive({ items: ['a', 'b'] })
state.items[0] = 'x'   // 可以检测到变化
state.items.length = 1 // 可以检测到变化
```

#### 3. 原生支持的操作

```javascript
// Vue 3中可以原生支持以下操作:
const state = reactive({ user: { name: '张三' } })

// 添加新属性
state.newProp = 'hello'

// 删除属性
delete state.user.name

// Map和Set操作
const collection = reactive(new Map())
collection.set('key', 'value')
```

## 3. 片段 (Fragments) 减少 DOM 节点

在Vue 3中，组件可以有多个根节点，这称为片段（Fragments）。这减少了不必要的包装元素，使DOM结构更加精简。

### Vue 2 的限制

```vue
<!-- Vue 2 中，组件必须有一个根节点 -->
<template>
  <div class="wrapper">  <!-- 多余的包装元素 -->
    <header>页头</header>
    <main>内容</main>
    <footer>页脚</footer>
  </div>
</template>
```

### Vue 3 的改进

```vue
<!-- Vue 3 中，组件可以有多个根节点 -->
<template>
  <header>页头</header>
  <main>内容</main>
  <footer>页脚</footer>
</template>
```

### 性能影响

- 减少了DOM节点数量，降低了内存使用
- 简化了DOM结构，提高了渲染性能
- 减少了CSS选择器的复杂度

### 在TransitionGroup中的应用

```vue
<!-- Vue 2 中必须使用包装元素 -->
<transition-group tag="ul" name="list">
  <li v-for="item in items" :key="item.id">{{ item.text }}</li>
</transition-group>

<!-- Vue 3 中可以不使用包装元素 -->
<transition-group name="list">
  <li v-for="item in items" :key="item.id">{{ item.text }}</li>
</transition-group>
```

## 4. 编译优化 (静态属性提升、事件缓存等)

Vue 3引入了一系列编译时优化，使运行时性能显著提升。

### 静态属性提升

编译器会识别并提升静态属性，减少渲染开销。

```vue
<template>
  <div class="container" style="margin: 10px" data-custom="value">
    <span>{{ message }}</span>
  </div>
</template>
```

编译结果：
```javascript
// 静态属性被提升，只创建一次
const hoisted = { 
  class: "container", 
  style: {"margin":"10px"}, 
  "data-custom": "value" 
}

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", hoisted, [
    _createElementVNode("span", null, _toDisplayString(_ctx.message), 1 /* TEXT */)
  ]))
}
```

### 事件侦听器缓存

Vue 3的编译器会缓存内联事件处理函数，避免重复创建。

```vue
<template>
  <button @click="increment">增加</button>
</template>
```

编译结果：
```javascript
export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("button", {
    onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.increment(...args)))
  }, "增加"))
}
```

### 块树 (Block Tree)

Vue 3引入了块的概念，通过标记可能变化的动态节点，实现精确的节点更新。

```vue
<template>
  <div>
    <h1>{{ title }}</h1>
    <p>静态文本</p>
    <MyComponent />
  </div>
</template>
```

在内部，编译器会标记哪些是动态的：

```javascript
export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", null, [
    _createElementVNode("h1", null, _toDisplayString(_ctx.title), 1 /* TEXT */),
    _createElementVNode("p", null, "静态文本", -1 /* HOISTED */),
    _createVNode(MyComponent)
  ]))
}
```

这里的数字标记（1, -1）表示节点的更新类型，帮助Vue精确地知道在重新渲染时哪些内容需要更新。

### v-once的优化

在不变内容上使用v-once可以跳过未来的所有更新检查：

```vue
<template>
  <div>
    <h1 v-once>{{ title }}</h1> <!-- 只渲染一次 -->
    <p>{{ message }}</p> <!-- 会根据message的变化重新渲染 -->
  </div>
</template>
```

编译结果：
```javascript
// 标题只计算一次，然后缓存
const _hoisted_1 = /*#__PURE__*/ _createElementVNode("h1", null, "静态标题", -1 /* HOISTED */)

export function render(_ctx, _cache) {
  return (_openBlock(), _createElementBlock("div", null, [
    _hoisted_1,
    _createElementVNode("p", null, _toDisplayString(_ctx.message), 1 /* TEXT */)
  ]))
}
```

## 5. 按需引入打包体积优化

Vue 3采用了基于ES模块的构建系统，支持tree-shaking，只打包实际使用的代码。

### 全局API的按需引入

```javascript
// Vue 2的全局引入方式
import Vue from 'vue'

Vue.nextTick(() => {})
Vue.use(/* ... */)
Vue.mixin(/* ... */)
Vue.component(/* ... */)
Vue.directive(/* ... */)

// Vue 3的按需引入方式
import { nextTick, createApp } from 'vue'
import MyPlugin from './plugins/MyPlugin'

nextTick(() => {})
const app = createApp(App)
app.use(MyPlugin)
app.mount('#app')
```

### 核心模块的优化

Vue 3的响应式系统、编译器等核心模块都被设计为可单独引入：

```javascript
// 仅引入响应式系统
import { ref, computed, watch } from 'vue'

// 仅在需要时引入高级API
import { onBeforeUnmount } from 'vue'

// 按需引入API，剩余未使用的API会被tree-shaking删除
```

### 组件库的按需引入

```javascript
// Vue 2 + Element UI - 全局引入
import Vue from 'vue'
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'

Vue.use(ElementUI)

// Vue 3 + Element Plus - 按需引入
import { createApp } from 'vue'
import { ElButton, ElSelect } from 'element-plus'
import 'element-plus/lib/theme-chalk/el-button.css'
import 'element-plus/lib/theme-chalk/el-select.css'

const app = createApp(App)
app.component(ElButton.name, ElButton)
app.component(ElSelect.name, ElSelect)
```

### 自动按需引入插件

使用[unplugin-vue-components](https://github.com/antfu/unplugin-vue-components)等工具自动进行按需引入：

```javascript
// vite.config.js
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default {
  plugins: [
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
}
```

然后在组件中直接使用：
```vue
<template>
  <el-button>按钮</el-button>
  <el-select v-model="value" />
</template>

<script setup>
// 无需手动导入，组件会自动按需引入
const value = ref('')
</script>
```

### 打包体积对比

一个典型的Vue应用打包体积对比：

| 版本 | 最小化+gzip后的大小 |
|------|------------------|
| Vue 2 完整版 | ~30KB |
| Vue 3 完整版 | ~30KB |
| Vue 3 按需引入 | 可低至 ~12KB |

### 打包分析

使用[rollup-plugin-visualizer](https://github.com/btd/rollup-plugin-visualizer)分析包大小：

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { visualizer } from 'rollup-plugin-visualizer'

export default defineConfig({
  plugins: [
    vue(),
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true
    })
  ]
})
```

## 6. 实用的性能优化技巧

### 使用v-memo跳过不需要更新的组件部分

```vue
<template>
  <div>
    <!-- 只有item.id变化时才会重新渲染 -->
    <div v-for="item in list" :key="item.id" v-memo="[item.id]">
      <div>ID: {{ item.id }}</div>
      <div>昂贵的计算: {{ expensiveOperation(item) }}</div>
      <!-- item的其他属性变化也不会导致此部分重新渲染 -->
    </div>
  </div>
</template>
```

### 组件懒加载

```javascript
// 组件懒加载
import { defineAsyncComponent } from 'vue'

// 基本用法
const AsyncComponent = defineAsyncComponent(() => 
  import('./components/HeavyComponent.vue')
)

// 高级用法
const AsyncComponentWithOptions = defineAsyncComponent({
  loader: () => import('./components/HeavyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,     // 显示loading组件前的延迟ms
  timeout: 3000   // 超时时间
})
```

### 大列表虚拟滚动

使用虚拟滚动组件如[vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)来优化大列表：

```vue
<template>
  <RecycleScroller
    class="scroller"
    :items="items"
    :item-size="32"
    key-field="id"
    v-slot="{ item }"
  >
    <div class="user-item">
      {{ item.name }}
    </div>
  </RecycleScroller>
</template>

<script setup>
import { RecycleScroller } from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'

const items = ref(Array.from({ length: 10000 }).map((_, i) => ({
  id: i,
  name: `用户 ${i}`
})))
</script>
```

### 使用keep-alive缓存组件状态

```vue
<template>
  <div>
    <button @click="current = 'A'">显示A</button>
    <button @click="current = 'B'">显示B</button>
    
    <keep-alive>
      <component :is="current"></component>
    </keep-alive>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import ComponentA from './ComponentA.vue'
import ComponentB from './ComponentB.vue'

const current = ref('A')
</script>
```

### 使用Suspense和异步组件配合优化加载体验

```vue
<template>
  <Suspense>
    <template #default>
      <AsyncPage />
    </template>
    <template #fallback>
      <LoadingSpinner />
    </template>
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent } from 'vue'
import LoadingSpinner from './LoadingSpinner.vue'

const AsyncPage = defineAsyncComponent(() => import('./DataPage.vue'))
</script>
```

异步组件：
```vue
<!-- DataPage.vue -->
<script setup>
// 使用顶层await，Suspense会等待它完成
const response = await fetch('https://jsonplaceholder.typicode.com/users')
const users = await response.json()
</script>

<template>
  <div>
    <h1>用户列表</h1>
    <ul>
      <li v-for="user in users" :key="user.id">{{ user.name }}</li>
    </ul>
  </div>
</template>
```
import{_ as a,e as l,j as e,o as n}from"./app-Cl65PKas.js";const s={};function r(h,i){return n(),l("div",null,i[0]||(i[0]=[e('<h2 id="一、vue-3-核心概念" tabindex="-1"><a class="header-anchor" href="#一、vue-3-核心概念"><span>一、Vue 3 核心概念</span></a></h2><h3 id="_1-vue-3-架构" tabindex="-1"><a class="header-anchor" href="#_1-vue-3-架构"><span>1. Vue 3 架构</span></a></h3><ul><li>采用 Monorepo 管理模式</li><li>源码组织结构变化</li><li>使用 TypeScript 重写</li><li>性能提升及优化策略</li></ul><h3 id="_2-响应式系统" tabindex="-1"><a class="header-anchor" href="#_2-响应式系统"><span>2. 响应式系统</span></a></h3><ul><li>Proxy 替代 Object.defineProperty</li><li>reactive 和 ref 的区别与使用</li><li>computed 和 watch 的实现原理</li><li>响应式原理深度解析</li><li>toRefs, toRef, unref 等工具函数使用</li></ul><h3 id="_3-组合式-api-composition-api" tabindex="-1"><a class="header-anchor" href="#_3-组合式-api-composition-api"><span>3. 组合式 API (Composition API)</span></a></h3><ul><li>setup 函数及其使用场景</li><li>生命周期钩子在组合式 API 中的变化</li><li>与 Options API 的比较优势</li><li>组合式函数 (Composables) 的设计模式</li><li>实际应用中的最佳实践</li></ul><h3 id="_4-性能优化" tabindex="-1"><a class="header-anchor" href="#_4-性能优化"><span>4. 性能优化</span></a></h3><ul><li>静态树提升 (Static Tree Hoisting)</li><li>基于 Proxy 的响应式系统性能优势</li><li>片段 (Fragments) 减少 DOM 节点</li><li>编译优化 (静态属性提升、事件缓存等)</li><li>按需引入打包体积优化</li></ul><h2 id="二、vue-3-新特性" tabindex="-1"><a class="header-anchor" href="#二、vue-3-新特性"><span>二、Vue 3 新特性</span></a></h2><h3 id="_1-内置组件" tabindex="-1"><a class="header-anchor" href="#_1-内置组件"><span>1. 内置组件</span></a></h3><ul><li>Teleport 组件用法及应用场景</li><li>Suspense 组件异步加载</li><li>Fragment 片段</li><li>异步组件的新写法</li></ul><h3 id="_2-新增-api" tabindex="-1"><a class="header-anchor" href="#_2-新增-api"><span>2. 新增 API</span></a></h3><ul><li>createApp 替代 new Vue</li><li>emits 选项声明事件</li><li>v-model 的变化与多个 v-model 绑定</li><li>全局 API 的调整 (如 app.use, app.component 等)</li><li>provide/inject 在组合式 API 中的使用</li></ul><h3 id="_3-模板与指令" tabindex="-1"><a class="header-anchor" href="#_3-模板与指令"><span>3. 模板与指令</span></a></h3><ul><li>v-if 与 v-for 优先级变化</li><li>v-bind 的变化 (合并行为)</li><li>多 v-model 支持</li><li>自定义指令的 API 变化</li></ul><h3 id="_4-typescript-支持" tabindex="-1"><a class="header-anchor" href="#_4-typescript-支持"><span>4. TypeScript 支持</span></a></h3><ul><li>defineComponent 增强类型推断</li><li>类型声明和泛型使用</li><li>组件 props 的类型声明</li><li>事件的类型定义</li><li>Volar 插件的使用与优势</li></ul><h2 id="三、vue-3-与-vue-2-的区别" tabindex="-1"><a class="header-anchor" href="#三、vue-3-与-vue-2-的区别"><span>三、Vue 3 与 Vue 2 的区别</span></a></h2><h3 id="_1-核心架构变化" tabindex="-1"><a class="header-anchor" href="#_1-核心架构变化"><span>1. 核心架构变化</span></a></h3><ul><li>源码架构对比</li><li>API 风格对比</li><li>生命周期对比</li><li>性能差异</li></ul><h3 id="_2-迁移策略" tabindex="-1"><a class="header-anchor" href="#_2-迁移策略"><span>2. 迁移策略</span></a></h3><ul><li>兼容性问题及常见解决方案</li><li>迁移工具使用</li><li>渐进式迁移最佳实践</li><li>第三方库兼容性问题处理</li></ul><h2 id="四、状态管理与路由" tabindex="-1"><a class="header-anchor" href="#四、状态管理与路由"><span>四、状态管理与路由</span></a></h2><h3 id="_1-pinia-与-vuex" tabindex="-1"><a class="header-anchor" href="#_1-pinia-与-vuex"><span>1. Pinia 与 Vuex</span></a></h3><ul><li>Pinia 与 Vuex 的区别</li><li>组合式 API 与状态管理的结合</li><li>状态管理最佳实践</li><li>持久化方案</li></ul><h3 id="_2-vue-router-4" tabindex="-1"><a class="header-anchor" href="#_2-vue-router-4"><span>2. Vue Router 4</span></a></h3><ul><li>路由守卫变化</li><li>组合式 API 中的路由使用</li><li>动态路由与权限控制</li><li>路由懒加载优化</li></ul><h2 id="五、实际应用与生态" tabindex="-1"><a class="header-anchor" href="#五、实际应用与生态"><span>五、实际应用与生态</span></a></h2><h3 id="_1-工程化" tabindex="-1"><a class="header-anchor" href="#_1-工程化"><span>1. 工程化</span></a></h3><ul><li>Vite 构建工具的使用与优势</li><li>单元测试与 E2E 测试</li><li>代码规范与最佳实践</li><li>CI/CD 部署策略</li></ul><h3 id="_2-组件设计" tabindex="-1"><a class="header-anchor" href="#_2-组件设计"><span>2. 组件设计</span></a></h3><ul><li>组件通信模式</li><li>组件封装与复用策略</li><li>基于组合式 API 的组件设计</li><li>高阶组件与组件插槽</li></ul><h3 id="_3-性能优化实践" tabindex="-1"><a class="header-anchor" href="#_3-性能优化实践"><span>3. 性能优化实践</span></a></h3><ul><li>大型应用性能优化策略</li><li>懒加载与代码分割</li><li>缓存策略</li><li>渲染性能优化技巧</li></ul><h3 id="_4-ssr-与-ssg" tabindex="-1"><a class="header-anchor" href="#_4-ssr-与-ssg"><span>4. SSR 与 SSG</span></a></h3><ul><li>Vue 3 中的服务端渲染</li><li>Nuxt 3 的使用与特点</li><li>静态站点生成</li><li>水合 (Hydration) 相关问题</li></ul><h2 id="六、常见面试问题" tabindex="-1"><a class="header-anchor" href="#六、常见面试问题"><span>六、常见面试问题</span></a></h2><h3 id="_1-原理类问题" tabindex="-1"><a class="header-anchor" href="#_1-原理类问题"><span>1. 原理类问题</span></a></h3><ul><li>谈谈对 MVVM 的理解</li><li>Vue 3 响应式原理详解</li><li>虚拟 DOM 及 Diff 算法</li><li>Vue 3 的编译优化</li></ul><h3 id="_2-实践类问题" tabindex="-1"><a class="header-anchor" href="#_2-实践类问题"><span>2. 实践类问题</span></a></h3><ul><li>大型项目的组件设计经验</li><li>如何处理性能瓶颈</li><li>项目中的状态管理方案设计</li><li>组件库设计与实现</li></ul><h3 id="_3-思考类问题" tabindex="-1"><a class="header-anchor" href="#_3-思考类问题"><span>3. 思考类问题</span></a></h3><ul><li>Vue 3 相比于其他框架的优势</li><li>前端发展趋势的思考</li><li>如何选择适合的技术栈</li><li>团队协作与技术决策</li></ul>',44)]))}const d=a(s,[["render",r],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/custom/front/vue/","title":"Vue 3 知识点大纲","lang":"zh-CN","frontmatter":{"title":"Vue 3 知识点大纲"},"headers":[],"readingTime":{"minutes":2.77,"words":832},"git":{"updatedTime":1741266639000,"contributors":[{"name":"yanxp","username":"yanxp","email":"yanxp@ti-net.com.cn","commits":1,"avatar":"https://avatars.githubusercontent.com/yanxp?v=4","url":"https://github.com/yanxp"}]},"filePathRelative":"custom/front/vue/index.md","categoryList":[{"id":"8b9035","sort":10000,"name":"custom"},{"id":"aee7b8","sort":10001,"name":"front"},{"id":"32ad8d","sort":10002,"name":"vue"}]}');export{d as comp,p as data};
